#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Candidate {
	char name[20];
	int votes;
} manchurian;

manchurian *pCandidates;

void vote(int num){
	pCandidates[num].votes++;
}


int main(int argc, char** argv){
	char *one;
	int i;
	int buf1sz = 16;	// stack
	one = malloc(buf1sz);	// heap
	pCandidates = (manchurian *) malloc(sizeof(manchurian)*50);  // heap
	strcpy(pCandidates[0].name, "Chase Hatch");
	pCandidates[0].votes=1;
	strcpy(pCandidates[1].name, "Phil Polstra");
	pCandidates[1].votes=2;
	// Distribute bought and paid for votes... 
	// Don't worry, this doesn't violate campaign finance laws.  :)
	vote(1);
	vote(2);
	vote(2);
	
	printf("Candidates:\n");
	for(i=0; i<2; i++){
		printf("\t%s, with %d votes\n", 
			pCandidates[i].name, pCandidates[i].votes);
	}
	if (argc > 1){
		strcpy(one, argv[1]);
	}
	printf("Your %d bytes:\n\t%s\n", buf1sz, argv[1]);
	printf("Candidates:\n");
	for(i=0; i<2; i++){
		printf("\t%s, with %d votes\n", 
			pCandidates[i].name, pCandidates[i].votes);
	}
	free(pCandidates);
	free(one);
	return(0);
}



/*
 *
 * Tryna analyze them regions again though, mellow
 * After first call to malloc, 583ce160 in EAX.  Heap starts at 583ce160-0x8
// After the first call to malloc (malloc(one))
583c:e150|                        00 00 00 00 21 00 00 00|        ....!...|
583c:e160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e170|00 00 00 00 00 00 00 00 00 00 00 00 89 1e 02 00|................|
583c:e180|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e190|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e1b0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After the second call to malloc (malloc(sizeof(manchurian)))
583c:e150|                        00 00 00 00 21 00 00 00|        ....!...|
583c:e160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e170|00 00 00 00 00 00 00 00 00 00 00 00 c1 04 00 00|................|
583c:e180|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e190|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e1b0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// Before call to puts #1 (strcpy(pCandidates[0]...), strcpy(pCandidates[2]...))
583c:e150|                        00 00 00 00 21 00 00 00|        ....!...|
583c:e160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
583c:e170|00 00 00 00 00 00 00 00 00 00 00 00 c1 04 00 00|................|
583c:e180|43 68 61 73 65 20 48 61 74 63 68 00 00 00 00 00|Chase Hatch.....|
583c:e190|00 00 00 00 01 00 00 00 50 68 69 6c 20 50 6f 6c|........Phil Pol|
583c:e1a0|73 74 72 61 00 00 00 00 00 00 00 00 02 00 00 00|stra............|
583c:e1b0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
// You can see that the buffer is written with [str\0], followed by eight bytes, 
// LSB of which is holding the value of the integer in the struct.

// After call to strcpy(one, argv[1])
583c:e150|                        00 00 00 00 21 00 00 00|        ....!...|
583c:e160|41 41 41 41 41 41 41 41 41 41 00 00 00 00 00 00|AAAAAAAAAA......|
583c:e170|00 00 00 00 00 00 00 00 00 00 00 00 c1 04 00 00|................|
583c:e180|43 68 61 73 65 20 48 61 74 63 68 00 00 00 00 00|Chase Hatch.....|
583c:e190|00 00 00 00 01 00 00 00 50 68 69 6c 20 50 6f 6c|........Phil Pol|
583c:e1a0|73 74 72 61 00 00 00 00 00 00 00 00 02 00 00 00|stra............|
583c:e1b0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After call to free(pCandidates)
583c:e150|                        00 00 00 00 21 00 00 00|        ....!...|
583c:e160|41 41 41 41 41 41 41 41 41 41 00 00 00 00 00 00|AAAAAAAAAA......|
583c:e170|00 00 00 00 00 00 00 00 00 00 00 00 c1 04 00 00|................|
583c:e180|d8 c7 ee f7 d8 c7 ee f7 00 00 00 00 00 00 00 00|................|
583c:e190|00 00 00 00 01 00 00 00 50 68 69 6c 20 50 6f 6c|........Phil Pol|
583c:e1a0|73 74 72 61 00 00 00 00 00 00 00 00 02 00 00 00|stra............|
583c:e1b0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After call to free(one);
583c:e150|                        00 00 00 00 21 00 00 00|        ....!...|
583c:e160|00 00 00 00 41 41 41 41 41 41 00 00 00 00 00 00|....AAAAAA......|
583c:e170|00 00 00 00 00 00 00 00 00 00 00 00 c1 04 00 00|................|
583c:e180|d8 c7 ee f7 d8 c7 ee f7 00 00 00 00 00 00 00 00|................|
583c:e190|00 00 00 00 01 00 00 00 50 68 69 6c 20 50 6f 6c|........Phil Pol|
583c:e1a0|73 74 72 61 00 00 00 00 00 00 00 00 02 00 00 00|stra............|
583c:e1b0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
 
 *
 */

// The intent is apparently to overwrite the second buffer such that we can control the votes 
// on the first candidate
// judging by the heap, a constructed string like follows should provide the overwrite:
// $(python -c 'print "A"*16; print "\x01"*12; print "\xc1\x04\x01\x01"; print "\x43\x68\x61\x73\x65\x20\x48\x61\x74\x63\x68\x20\x20\x20\x20\x20\x20\x20"; print "\xff";')

// but you'll find that, because of the inability to place null bytes, the offset specified in the size exceeds the bounds of the heap, and therefore results in a crash when the program tries to access the out-of-bounds memory region.
