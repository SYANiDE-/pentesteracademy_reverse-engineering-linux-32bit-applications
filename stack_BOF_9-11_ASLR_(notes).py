#!/usr/bin/env python3
import os, struct

# ASLR IS/would_be ENABLED:
# sudo su
# echo 2 > /proc/sys/kernel/randomize_va_space


NOTES="""
### Problems:
    1. Library and binary load addresses are randomized at runtime
### Solutions:
    1.  Use the PLT Procedural Linkage Table
        "Return to PLT" : https://sploitfun.wordpress.com/2015/05/08/bypassing-aslr-part-i/
    2.  Overwrite the GOT Global Offset Table
        "Overwrite or dereference GOT entries": https://sploitfun.wordpress.com/2015/05/08/bypassing-aslr-part-iii/
    3.  Brute Force
        "Brute force guessing libc base address" : https://sploitfun.wordpress.com/2015/05/08/bypassing-aslr-part-ii/

### Backgrounds:
    ### PLT:
    Shared libs are loaded into multiple programs at once
    1. Text segment is common to all progs
    2. Each prog has its own private data segment
    3. PIC Position Independent Code in libs
    ### Lib functions are not called directly
    1. A stub in the PLT is called
    2. Stub looks up address in GOT
    ### How can we exploit?:
    1. We just have to call the function using the stub defined in the PLT
    ### LIMITATIONS:
    1. PLT ONLY lists functions that were called in the program!

## The gist:
    It is given by the instructor that you just need to debug and find the address called when calling the @plt stub for a given function.  However, I'm finding that this doesn't work.  The following article also gives the same instruction:
    https://sploitfun.wordpress.com/2015/05/08/bypassing-aslr-part-i/
    But as mentioned, I am finding this not reproducable.   Example three runs, the locations of the instructions to call strcpy@plt, and the address the call lands on when stepping into the instruction:
    565b:4579   call test.elf!strcpy@plt  step_in -> 565b:43e0
    5656:3579   call test.elf!strcpy@plt  step_in -> 5656:33e0
    565a:9579   call test.elf!strcpy@plt  step_in -> 565a:93e0

    Test environment:
    Linux Reversing-Sandbox 4.15.0-58-generic #64-Ubuntu SMP Tue Aug 6 11:12:41 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux
    Ubuntu 18.04.3 LTS \n \l
"""

NOTES="""
### BOF 10
### GOT:
    Stores location of library functions
    Two ways to attack:
    1. Overwrite
    2. Dereference (store offset in register)
    Use objdump -R [bin] to locate GOT table entries
### How does this work:
    Need to find offsets in the target binary or lib:
        readelf -s [bin] |grep -iE "src|target"
    1. The called function
    2. Thed desired target function
    Then you need to calculate the signed delta between the two
        delta = target - src
    OVERWRITE:  Then you overwrite the GOT
        GOT[src] = GOT[src] + delta
    DEREFERENCE:  OR you dereference and store into a register
        EAX = GOT[src]
        EAX = EAX + delta
### Requirements:
    Based heavily on ROP Return Oriented Programming
    Makes use of code immediately preceding a RET instruction
    These arbitrary blocks of code that precede RET instructions are called ROPGADGETS
    Several tools exist to help locate/identify ROPGADGETS; here are three examples:
    - Rp++
    - RopeMe
    - ROPgadget
    Using ROPGADGETS, you build up the function you want
    "Payload Already Inside:  Data Reuse for ROP Exploits" : http://media.blackhat.com/bh-us-10/whitepapers/Le/BlackHat-USA-2010-Le-Paper-Payload-already-inside-data-reuse-for-ROP-exploits-wp.pdf
    """


NOTES="""
### Stack Canary:
    The stack canary is a value put on the stack; not a return address or argument.
    It's used to prevent/detect stack modifications.
    When stack protector is enabled, extra code is added to function epilogues to check for
    , the stack canary
    Compiler inserts extra code
    There are two common types:
    1.  Terminator
        Contains characters that are incompatible with strcpy, gets, etc.
        Example:  0x000a0dff
            \x00  null                          # strcpy input terminates by \x00
            \x0a  newline                       # gets and printf, etc, terminate by \x0a
            \x0d  carriage return               # same
            \xff  commonly interpreted as EOF   # 
        Static value can easily be searched on;  makes things easier for attacker in 
        , some cases because then the structure of frame is known and can be duplicated
    2.  Random
        Doesn't stop string operations
        Only detects tampering
        Much harder to bypass / code around.
        These are extremely difficult to exploit around... ON LINUX
        ON WINDOWS SEH Structured Exception Handler can be used, intentionally raising 
        , exception in order to have the exception handled by malicious code
        Brute forcing random canary is not likely

"""

### http://intx0x80.blogspot.com/2018/04/bypass-aslrnx-part-1.html
        


