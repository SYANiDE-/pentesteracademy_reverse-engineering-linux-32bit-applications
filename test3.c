#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct SalesItem {
	int id;
	float price;
	int qty;
	char description[20];
} SI;

int main(int argc, char** argv){
	char *one, *two;
	int buf1sz = 16;	// stack
	int buf2sz = 1024;	// stack
	one = malloc(buf1sz);	// heap
	two = malloc(buf2sz);	// heap
	SI ticket;
	ticket.id =1;
	ticket.price= 32.99;
        ticket.qty = 12; 
	strcpy(ticket.description, "Box 'o Bagels");
	SI *tkt = (SI*)two;
	memcpy(two, &ticket, sizeof(struct SalesItem));
	printf("Your %d bytes:\n%s\n", buf1sz, argv[1]);
 	printf("Ticket before: \n\t%d\n\t%8.2f\n\t%d\n\t%s\n", 
			tkt->id, tkt->price, tkt->qty, tkt->description);
	if (argc > 1){
		strcpy(one, argv[1]);
	}
 	printf("Ticket after: \n\t%d\n\t%8.2f\n\t%d\n\t%s\n", 
			tkt->id, tkt->price, tkt->qty, tkt->description);
	free(two);
	free(one);
	return(0);
}




/*
 *
// // // // clean run:
//
// After call to malloc(one), EAX holds 5777c160.  Chunk starts at 5777c160-0x8
// Note the 16 bytes after the chunk.. That's the chunk preamble of the next
// chunk.  Of special interest is those last eight bytes 

// After call to malloc(one)
5777:c150|                        00 00 00 00 21 00 00 00|        ....!...| // note "one"
5777:c160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
5777:c170|00 00 00 00 00 00 00 00 00 00 00 00 89 1e 02 00|................| // note "two"
5777:c180|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
5777:c190|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
5777:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// after call to malloc(two)
5777:c150|                        00 00 00 00 21 00 00 00|        ....!...| // note "one"
5777:c160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
5777:c170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................| // note "two"
5777:c180|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
5777:c190|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
5777:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// Before call to strcpy:  (struct memcpy'd into "two")
5777:c150|                        00 00 00 00 21 00 00 00|        ....!...|
5777:c160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
5777:c170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|
5777:c180|01 00 00 00 c3 f5 03 42 0c 00 00 00 42 6f 78 20|.......B....Box | // note
5777:c190|27 6f 20 42 61 67 65 6c 73 00 5e 56 30 3a b2 ff|'o Bagels.^V0:..| // note
5777:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After call to strcpy(strcpy(one, argv[1])):
5777:c150|                        00 00 00 00 21 00 00 00|        ....!...|
5777:c160|41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41|AAAAAAAAAAAAAAAA| // note
5777:c170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|
5777:c180|01 00 00 00 c3 f5 03 42 0c 00 00 00 42 6f 78 20|.......B....Box |
5777:c190|27 6f 20 42 61 67 65 6c 73 00 5e 56 30 3a b2 ff|'o Bagels.^V0:..|
5777:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After calling free(two):
5777:c150|                        00 00 00 00 21 00 00 00|        ....!...|
5777:c160|41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41|AAAAAAAAAAAAAAAA|
5777:c170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|
5777:c180|d8 97 ef f7 d8 97 ef f7 00 00 00 00 00 00 00 00|................| // note first eight bytes
5777:c190|27 6f 20 42 61 67 65 6c 73 00 5e 56 30 3a b2 ff|'o Bagels.^V0:..|
5777:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After calling free(one):
5777:c150|                        00 00 00 00 21 00 00 00|        ....!...|
5777:c160|00 00 00 00 41 41 41 41 41 41 41 41 41 41 41 41|....AAAAAAAAAAAA| //note first four bytes
5777:c170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|
5777:c180|d8 97 ef f7 d8 97 ef f7 00 00 00 00 00 00 00 00|................|
5777:c190|27 6f 20 42 61 67 65 6c 73 00 5e 56 30 3a b2 ff|'o Bagels.^V0:..|
5777:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

 *
 *
 */


//  We might overwrite the struct or second buffer with something like follows:
//  ./test3.elf $(perl -e 'print "A"x16;print "\x01"x12;print "\x11\x04\x01\x01"; print "\x01010101"; print "\x01\x01\x01\01"; print "\x01"x4; print "Diamonds";')
// However as pointed out, There are a lot of \x01 in place of where a needed null might need to be, mkaing things not as intended.   The instructor suggests "hint":  Return addresses & plt


/*
 *
// // // // DIRTY DIRTY run:
//
// After call to malloc(one), EAX holds 56cdc160.  Chunk starts at 56cdc160-0x8
// Note the 16 bytes after the chunk.. That's the chunk preamble of the next
// chunk.  Of special interest is those last eight bytes 

// After call to malloc(one)
56cd:c150|                        00 00 00 00 21 00 00 00|        ....!...|
56cd:c160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
56cd:c170|00 00 00 00 00 00 00 00 00 00 00 00 89 1e 02 00|................|
56cd:c180|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
56cd:c190|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
56cd:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// after call to malloc(two)
56cd:c150|                     00 00 00 00 00 21 00 00 00|       .....!...|
56cd:c160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
56cd:c170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|
56cd:c180|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
56cd:c190|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
56cd:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// Before call to strcpy:  (struct memcpy'd into "two")
56cd:c150|                        00 00 00 00 21 00 00 00|        ....!...|
56cd:c160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
56cd:c170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|
56cd:c180|01 00 00 00 c3 f5 03 42 0c 00 00 00 42 6f 78 20|.......B....Box |
56cd:c190|27 6f 20 42 61 67 65 6c 73 00 5b 56 60 1a eb ff|'o Bagels.[V`...|
56cd:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After call to strcpy(strcpy(one, argv[1])):
56cd:c150|                        00 00 00 00 21 00 00 00|        ....!...|
56cd:c160|41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41|AAAAAAAAAAAAAAAA|
56cd:c170|01 01 01 01 01 01 01 01 01 01 01 01 11 04 01 01|................|
56cd:c180|01 30 31 30 31 30 31 01 01 01 01 01 01 01 01 44|.010101........D|
56cd:c190|69 61 6d 6f 6e 64 73 00 73 00 5b 56 60 1a eb ff|iamonds.s.[V`...|
56cd:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After calling free(two):
(crash)

56cd:c150|                        00 00 00 00 21 00 00 00|        ....!...|
56cd:c160|41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41|AAAAAAAAAAAAAAAA|
56cd:c170|01 01 01 01 01 01 01 01 01 01 01 01 11 04 01 01|................|
56cd:c180|01 30 31 30 31 30 31 01 01 01 01 01 01 01 01 44|.010101........D|
56cd:c190|69 61 6d 6f 6e 64 73 00 73 00 5b 56 60 1a eb ff|iamonds.s.[V`...|
56cd:c1a0|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|

// After calling free(one):
(couldn't make it here)
 *
 *
 */


