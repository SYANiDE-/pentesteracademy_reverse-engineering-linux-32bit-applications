#!/usr/bin/env python3


NOTES="""
### Heap variables:
    Are dynamic; size not known at compile time
    Great for larger items such as:
        Objects
        Structures
        Large Arrays
    Needed for something to outlive its defining brackets
    Uses manual allocation/deallocation
        New/Delete (c++)
        Malloc, calloc, free, etc
    Slower performance than stack variables

Heap implementations:
    There are many!
        Dlmalloc
        Ptmalloc (recent Linux GCC)
        Tcmalloc
        Jemalloc
        Nedmalloc
        Hoard
        Custom
    Typically named after their creator
    OK to roll your own, unlike encryption protocols!
    Heap is manual alloc, whereas stack is automatic create/delete/cleanup
    Heap is persistent;  because need to define cleanup
    Unlimited;  not limited in space (virtual memory, physical, etc)
    A lot slower than stack; lots of overhead
    Grows up rather than down
    Usually requires at least two allocations
    Harder to execute than a stack BOF.

Heap BOFs #3:
    Stack allocation is a strange beast.  Supposing you allocated a 32-byte variable, on 
    , the heap, it will actually occupy 40 bytes.
    With:
    edb --run ./test2.elf $(perl -e 'print "A"x16';)
    Supposing a variable allocation of 16 bytes:

    ## Before the strcpy operation:
    On the stack:  ffbb:50f0|57fb7160|`q.W|
    Dump that location:
    57fb:7160|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
    57fb:7170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|

    ## After the strcpy operation:
    On the stack:  ffbb:50f0|57fb7160|`q.W|ASCII "AAAAAAAAAAAAAAAA"
    Dump at that location:
    57fb:7160|41 41 41 41 41 41 41 41 41 41 41 41 41 41 41 41|AAAAAAAAAAAAAAAA|
    57fb:7170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|

    ## After calling free on the variable:
    57fb:7160|00 00 00 00 41 41 41 41 41 41 41 41 41 41 41 41|....AAAAAAAAAAAA|
    57fb:7170|00 00 00 00 00 00 00 00 00 00 00 00 11 04 00 00|................|

    Overview of chunks !!!IMPORTANT:
    https://sourceware.org/glibc/wiki/MallocInternals

    All chunks are multiples of 8 bytes, power-of-two aligned.

    When a (32bit) chunk is in use:
    -------------------------
    | previous_size         |  <- mchunk ptr
    ________________________
    | size            | AMP |A: Allocated Memory; M: MMap'd; P: prev in use
    -------------------------
    |       payload         |
    |                       |
    |                       |
    _________________________
    | size            | AMP | p=1
    -------------------------
    
    The chunk header therefore tells and references what the previous chunk in use' size
    , is, as well as flags for it's state and size of the allocation.  The chunk returned 
    , by malloc is between the underscore lines.  Mchunkptr points to the size field of the
    , previous chunk.  Chunks are adjacent to one another, and therefore chaining or
    , following the mapping is possible by following the pointers and increment/decrement
    , the pointer by size.


    When a 32bit chunk is free:
     -------------------------
    | previous_size         |  <- mchunk ptr
    ________________________
    | size            | AMP |A: Allocated Memory; M: MMap'd; P: prev in use
    -------------------------
    | fwd                   | <--\ 
    -------------------------     ---large chunks only  
    | bck                   | <--/
    -------------------------
    | fd_nextsize           |
    -------------------------
    | bk_nextsize           |
    -------------------------
    |       payload         |
    |                       |
    |                       |
    -------------------------
    | prev_size             |
    _________________________
    | size           |  AMP | p=0
    -------------------------

    Gross oversimplification... RTFM!  --> https://sourceware.org/glibc/wiki/MallocInternals

    The instructor was trying to illustrate the point that if you give enough of an overflow
    , you can overwrite the mchunkptr of an adjacent chunk.

    """
